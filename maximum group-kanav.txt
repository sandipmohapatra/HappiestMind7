Maximum Groups
 
 You are given N number of candles in the form of integers. Each integer represents the color of the candle.
 Your aim is to arrange candles in groups of three such that:
 1) No two candles in each group formed have the same color.
 2) Each candle can be present in at most one group.
  
 Print the maximum number of groups of candles that can be formed. 
  
 Function Description
 In the provided code snippet, implement the provided findCount(...) method using the variables to print the maximum number of groups of candles that can be formed. You can write your code in the space below the phrase “WRITE YOUR LOGIC HERE”.
 
 There will be multiple test cases running so the Input and Output should match exactly as provided.
 
 
 Input Format
 The first line contains an integer N.
 The second line contains N integers denoting different colors of candles.
 
 Sample Input
 12 -- denotes N
 1 2 3 3 2 1 1 2 3 3 3 3 -- denotes the color of N candles
  
 Constraints
 3 <= N <= 65336.
 0<= A[i] <= 65356.
 
 Output Format
 The output should print the count of the number of groups possible.
 
 Sample Output
 3
  
 Explanation
 We can form 3 groups of {1,2,3}. This is the maximum number of groups possible.
-------------------------------------------------
import java.util.*;
 import java.io.*;
 import java.lang.Math; 
 public class Main
 {
  public static int findCount(int N,int[] A)
  { 
  int result =0; 
  //write your Logic here: 
  
  ArrayList<Integer> dest = new ArrayList<Integer>();
  ArrayList<Integer> curlst = new ArrayList<Integer>();
  ArrayList<Integer>tempList=new ArrayList<Integer>();
  
  for(int num:A)
	  tempList.add(num);
  int total = A.length;
  int count = 0;
  for (int i=0;i<total;i++)
  {

      

      if (dest.contains(A[i])) curlst.add(A[i]);
      else
      {
          dest.add(A[i]);
          count++;
          
      }
      if (count == 3)
      {
          result++;
          dest = new ArrayList<Integer>();
          count = 0;
      }


  }
  tempList.subList(0, tempList.size()-1).clear();
  tempList.addAll(curlst);
  tempList.addAll(dest);
   return result;
  }
  public static void main (String[]args)
  {
  Scanner sc = new Scanner (System.in); 
  int N = sc.nextInt (); 
  int[] A = new int[N];
  for (int i = 0; i < N; i++)
  {
  A[i] = sc.nextInt ();
  }  
  sc.close (); 
  System.out.print(findCount(N,A));
  }
 }
--------------------------------------------------------------------------------------------
StandardInput					ExpectedOutput
"150
1 4 2 5 1 3 3 2 1 3 2 5 6 4 6 0 3 1 2 2 3 0 5 2 2 5 5 6 1 5 5 0 3 5 3 2 1 0 2 2 1 4 5 0 6 3 6 2 2 1 3 5 0 1 1 2 4 4 1 3 2 6 4 5 3 5 5 4 3 0 5 3 2 3 3 2 4 0 2 0 0 3 5 0 4 4 0 2 1 1 5 4 5 0 0 1 4 6 4 0 4 0 3 0 1 5 0 6 3 0 6 1 4 2 6 6 0 6 6 1 5 3 3 4 3 4 3 5 1 5 4 3 5 5 1 0 1 1 4 5 0 3 4 4 3 4 3 3 3 3"			50
"80
1 4 2 5 1 3 3 2 1 3 2 5 6 4 6 0 3 1 2 2 3 0 5 2 2 5 5 6 1 5 5 0 3 5 3 2 1 0 2 2 1 4 5 0 6 3 6 2 2 1 3 5 0 1 1 2 4 4 1 3 2 6 4 5 3 5 5 4 3 0 5 3 2 3 3 2 4 0 2 0"					26
"50
3 1 2 0 3 0 1 2 4 1 2 2 0 4 3 1 0 1 2 1 1 3 2 4 2 0 2 3 2 0 4 2 2 3 4 2 3 1 1 2 4 3 1 4 4 2 3 4 0 0"	
												16